# Пример испита из предмета „Објектно-оријентисано програмирање 1“ — нови сет задатака (са решењима)

Намера овог испита је да проверимо разумевање важних ООП и C++ тема који су покривени у курсу: дизајн класа, полиморфизам, управљање ресурсима (RAII), изузеци, STL и алгоритми, семантика копирања/померања, `const`-правила, и синтаксичке/повезивачке грешке. Кодовање је у C++11 (санкционисано коришћење `unique_ptr`, ламбди итд.). Испит има 7 задатака; сваки задатак прати кратко **решење** (код + објашњење).

---

## 1. (Дизајн хијерархије и рачун површина — 15 поена)

Дизајнирати хијерархију класа за геометријске облике `Shape` (апстрактна класа) и конкретне облике `Rectangle`, `Circle`, `Triangle`.
Сваки облик мора да реализује:

* `virtual double area() const = 0;`
* `virtual void ispisi() const = 0;`
* виртуалан деструктор.

У `main()`:

* направити `std::vector<std::unique_ptr<Shape>>` и додати неколико облика,
* обрадити грешке (нпр. негативне димензије бацају `std::invalid_argument`),
* исписати податке о сваком облику и израчунати укупну површину коришћењем STL-а.

### Решење

```cpp
// shapes.cpp
#include <iostream>
#include <vector>
#include <memory>
#include <numeric>
#include <algorithm>
#include <stdexcept>
#include <cmath>

constexpr double PI = 3.14159265358979323846;

class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
    virtual void ispisi() const = 0;
};

class Rectangle : public Shape {
    double w, h;
public:
    Rectangle(double w, double h) : w(w), h(h) {
        if (w <= 0 || h <= 0) throw std::invalid_argument("Rectangle: negativne ili nule dimenzije");
    }
    double area() const override { return w * h; }
    void ispisi() const override {
        std::cout << "Rectangle: w=" << w << " h=" << h << " area=" << area() << '\n';
    }
};

class Circle : public Shape {
    double r;
public:
    Circle(double r) : r(r) {
        if (r <= 0) throw std::invalid_argument("Circle: negativan ili nula poluprecnik");
    }
    double area() const override { return PI * r * r; }
    void ispisi() const override {
        std::cout << "Circle: r=" << r << " area=" << area() << '\n';
    }
};

class Triangle : public Shape {
    double base, height;
public:
    Triangle(double b, double h) : base(b), height(h) {
        if (b <= 0 || h <= 0) throw std::invalid_argument("Triangle: negativne ili nule dimenzije");
    }
    double area() const override { return 0.5 * base * height; }
    void ispisi() const override {
        std::cout << "Triangle: base=" << base << " height=" << height << " area=" << area() << '\n';
    }
};

int main() {
    std::vector<std::unique_ptr<Shape>> shapes;

    // прављење облика појединачно у try блоковима да једна грешка не поквари све
    try { shapes.push_back(std::make_unique<Rectangle>(3.0, 4.0)); }
    catch (const std::exception& e) { std::cerr << e.what() << '\n'; }

    try { shapes.push_back(std::make_unique<Circle>(1.5)); }
    catch (const std::exception& e) { std::cerr << e.what() << '\n'; }

    try { shapes.push_back(std::make_unique<Triangle>(3.0, 4.0)); }
    catch (const std::exception& e) { std::cerr << e.what() << '\n'; }

    try { shapes.push_back(std::make_unique<Rectangle>(-1.0, 2.0)); } // намерна грешка
    catch (const std::exception& e) { std::cerr << "Greska pri kreiranju: " << e.what() << '\n'; }

    // испис облика
    for (const auto& s : shapes) s->ispisi();

    // укупна површина — користимо std::accumulate
    double total = std::accumulate(shapes.begin(), shapes.end(), 0.0,
        [](double acc, const std::unique_ptr<Shape>& p){ return acc + p->area(); });

    std::cout << "Total area = " << total << '\n';

    // пример корисћења другог STL алгоритма
    auto count_big = std::count_if(shapes.begin(), shapes.end(),
        [](const std::unique_ptr<Shape>& p){ return p->area() > 5.0; });

    std::cout << "Number of shapes with area > 5.0: " << count_big << '\n';
}
```

**Објашњење:**
Покажује полиморфизам (виртуалне методе), управљање ресурсима (`unique_ptr`), изузетке за неважеће димензије и употребу STL алгоритама за агрегирање података.

---

## 2. (Преуреди код у ООП стил — 10 поена)

Постоји фрагмент кода који бира начин плаћања преко низа `if`-ова:

```cpp
if (method == "cash") processCash(amount);
else if (method == "card") processCard(amount);
else if (method == "paypal") processPaypal(amount);
```

Прилагодити тај код користећи ООП (абстрактну базну класу и изведене класе за сваки начин плаћања). Прикажи пример коришћења (одабир плаћања и позив `process`).

### Решење

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

class Payment {
public:
    virtual ~Payment() = default;
    virtual bool process(double amount) const = 0;
};

class CashPayment : public Payment {
public:
    bool process(double amount) const override {
        std::cout << "Processing cash: " << amount << '\n';
        return true;
    }
};

class CardPayment : public Payment {
    std::string cardNumber;
public:
    CardPayment(const std::string& num) : cardNumber(num) {}
    bool process(double amount) const override {
        std::cout << "Processing card (" << cardNumber << "): " << amount << '\n';
        return true;
    }
};

class PayPalPayment : public Payment {
    std::string account;
public:
    PayPalPayment(const std::string& acc) : account(acc) {}
    bool process(double amount) const override {
        std::cout << "Processing PayPal (" << account << "): " << amount << '\n';
        return true;
    }
};

int main() {
    std::string method = "card"; // овај стринг би могао доћи од корисничког улаза
    double amount = 42.50;

    std::unique_ptr<Payment> p;

    if (method == "cash") p = std::make_unique<CashPayment>();
    else if (method == "card") p = std::make_unique<CardPayment>("1234-5678-9012-3456");
    else if (method == "paypal") p = std::make_unique<PayPalPayment>("user@example.com");
    else {
        std::cerr << "Nepoznat nacin placanja\n";
    }

    if (p) {
        if (!p->process(amount)) {
            std::cerr << "Processing failed\n";
        }
    }
}
```

**Објашњење:**
Овако је код отворен за проширење (лакше додати нови начин плаћања) и затворен за измене (не мењамо логику позива). Студент који правилно користи виртуалну базну класу добија похвалу.

---

## 3. (Врста грешке — 6 поена)

Пронађи грешку и назначи да ли је то грешка при превођењу, повезивању (linking) или извршавању, и како је исправити:

```cpp
// counter.h
class Counter {
public:
    static int count;
    Counter() { ++count; }
};

// main.cpp
#include "counter.h"
#include <iostream>
int main() {
    Counter c;
    std::cout << Counter::count << std::endl;
}
```

### Решење

* **Врста грешке:** Грешка при повезивању (linker error).
* **Објашњење:** Статички члан `Counter::count` је деклараisan у класи, али није дефинисан у некој `.cpp` датотеци; линкер не налази симбол.
* **Исправка:** Додати дефиницију статичког члана (обично у `counter.cpp` или у једном `.cpp` који се компајлира):

```cpp
// counter.cpp
#include "counter.h"

int Counter::count = 0;
```

Алтернатива за једнофајлни пример:

```cpp
// main.cpp
#include <iostream>

class Counter {
public:
    static int count;
    Counter() { ++count; }
};

int Counter::count = 0;

int main() {
    Counter c;
    std::cout << Counter::count << std::endl;
}
```

---

## 4. (Константност — који overload се позива? — 6 поена)

Размотри следећу класу и наведите која верзија `get()` се позива у сваком случају који следи (`a`, `b`, `c`):

```cpp
class A {
    int x;
public:
    A(int v) : x(v) {}
    int& get() { return x; }
    int get() const { return x; }
};

int main() {
    // a)
    A* a = new A(10);
    a->get();

    // b)
    const A* b = new A(20);
    b->get();

    // c)
    A* const c = new A(30);
    c->get();
}
```

### Решење

* а) `A* a = new A(10);` — позива се **неконстантна** верзија `int& get()` јер објекат није `const`.
* б) `const A* b = new A(20);` — позива се **константна** верзија `int get() const` јер је показивач на `const` објекат.
* в) `A* const c = new A(30);` — позива се **неконстантна** верзија `int& get()` јер је објекат неконстантан; `A* const` значи да је показивач константан, не и објекат.

**Напомена:** константност објекта (није показивача) одређује избор `const` метoде.

---

## 5. (Приступни ниво и `friend`) — 8 поена

Потребно је имплементирати класу `Log` која чува текстуалне поруке у `std::vector<std::string> messages`. Захтев: операцију `write(const std::string&)` **могу да позову само**:

* класа `DebugTool`, и
* класе изведене из `Log`.

Имплементирати `Log`, `DebugTool` и пример изведене класе `FileLog` који показују да ограничење ради.

### Решење

```cpp
#include <iostream>
#include <vector>
#include <string>

class DebugTool; // унапредна декларација

class Log {
protected:
    // protected: дозвољава класама изведеним из Log да пишу
    void write(const std::string& msg) {
        messages.push_back(msg);
    }

public:
    virtual ~Log() = default;

    // дозвољено је да свако види/испише садржај, али само `write` је ограничен
    void dump() const {
        for (const auto& m : messages) std::cout << m << '\n';
    }

private:
    std::vector<std::string> messages;

    // DebugTool има приступ write() чак и ако је она protected
    friend class DebugTool;
};

class DebugTool {
public:
    void logSomething(Log& l, const std::string& msg) {
        // могуће зато што је DebugTool пријатељ класе Log
        l.write("DEBUG: " + msg);
    }
};

class FileLog : public Log {
public:
    void saveEvent(const std::string& e) {
        // могуће зато што је write() protected и FileLog је изведена из Log
        write("FILE: " + e);
    }
};

int main() {
    Log base;
    FileLog fl;
    DebugTool d;

    // Ово не би смео да ради (ако желимо Да само DebugTool и изведене класе пишу),
    // ако се покуша директно: base.write("hi"); // -> компајл грешка (write је protected)

    d.logSomething(base, "something happened"); // allowed via friend
    fl.saveEvent("file opened");                // allowed via derived

    std::cout << "Base log:\n"; base.dump();
    std::cout << "FileLog:\n"; fl.dump();
}
```

**Објашњење:**
`write` је `protected` — дозвољава изведеним класама да пишу. Додатно, `DebugTool` је проглашен `friend`-ом како би могао да позива `write` на објектима класе `Log`. Ово испуњава захтев „само DebugTool и класе изведене из Log“.

---

## 6. (Rule of Five — управљање ресурсом) — 15 поена

Класа `Buffer` управља динамичким низом `char`. Дефинисати `Buffer` тако да исправно ради копирање и померање: обезбедити деструктор, копирајући конструктор, оператер присвајања копирањем, померајући конструктор и оператер присвајања померањем. Такође обезбедити методе `size()` и `data()`.

### Решење

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>

class Buffer {
    size_t sz;
    char* data_;
public:
    explicit Buffer(size_t n = 0) : sz(n), data_(n ? new char[n] : nullptr) {}

    ~Buffer() { delete[] data_; }

    // copy constructor
    Buffer(const Buffer& other) : sz(other.sz), data_(other.sz ? new char[other.sz] : nullptr) {
        if (data_) std::memcpy(data_, other.data_, sz);
    }

    // copy assignment
    Buffer& operator=(const Buffer& other) {
        if (this == &other) return *this;
        char* newdata = other.sz ? new char[other.sz] : nullptr;
        if (newdata && other.data_) std::memcpy(newdata, other.data_, other.sz);
        delete[] data_;
        data_ = newdata;
        sz = other.sz;
        return *this;
    }

    // move constructor
    Buffer(Buffer&& other) noexcept : sz(other.sz), data_(other.data_) {
        other.sz = 0;
        other.data_ = nullptr;
    }

    // move assignment
    Buffer& operator=(Buffer&& other) noexcept {
        if (this == &other) return *this;
        delete[] data_;
        sz = other.sz;
        data_ = other.data_;
        other.sz = 0;
        other.data_ = nullptr;
        return *this;
    }

    size_t size() const { return sz; }
    char* data() const { return data_; }
};

int main() {
    Buffer a(10);
    Buffer b = a;            // копирање
    Buffer c = std::move(a); // померање
    std::cout << "b.size = " << b.size() << ", c.size = " << c.size() << '\n';
}
```

**Објашњење:**
Код поштује *Rule of Five*: кад класa ручно управља ресурсом (динамичка памет), мора адекватно да дефинише копирање и померање (или да онемогући неке операције). Постоји и `noexcept` за померање да би STL могао да оптимизује.

---

## 7. (STL алгоритми и lambda — 10 поена)

Дат је вектор `v = {1, 2, 3, 4, 5, 2, 3, 1}`.
Задаци:

1. Направити нови вектор који садржи квадрате вредности `v` (користити `std::transform` и `std::back_inserter`).
2. Уклонити дупликате из новог вектора (користити `std::sort` и `std::unique`).
3. Исписати резултат.

### Решење

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> v{1,2,3,4,5,2,3,1};

    // 1. transform -> squares
    std::vector<int> squares;
    squares.reserve(v.size());
    std::transform(v.begin(), v.end(), std::back_inserter(squares),
                   [](int x){ return x * x; });

    // 2. remove duplicates: sort + unique + erase
    std::sort(squares.begin(), squares.end());
    squares.erase(std::unique(squares.begin(), squares.end()), squares.end());

    // 3. print
    for (int s : squares) std::cout << s << ' ';
    std::cout << '\n';
}
```

**Очекује се излаз (редослед сортиран):**

```
1 4 9 16 25
```

---

### Напомене за оцењивање и коментар

* Кодови треба да буду јасни и компајл стабилни (C++11 или новији).
* Посебно се боде исправно руковање ресурсима (избегавање `delete` на истом показивачу два пута, правилна копија/померање).
* Проверити да ли студент користи виртуалан деструктор у базним класама које имају виртуалне методе.
* За питања о грешкама (linking/compilation/runtime) очекује се тачна класификација и кратко објашњење.
* Код у решењима служи као пример — при оцењивању важни су идеја и исправност, не стил.
